# Java OOP
 Goals
The aim is to:
- Know how to analyze a given problem and code a solution from a UML class diagram and specifications, following the object-oriented programming paradigm.
- You will face a medium size program based on an architectural pattern such as MVC (Model-View-Controller).

Learning achievements
- Code a program based on an architecture pattern such as MVC (Model-View-Controller).
- Perform some tasks related to the creation of graphical interfaces for a Java program.
- Use, in a basic way, event-driven programming.
- Use test files in JUnit to determine that a program is correct.
- Use with some fluency an integrated development environment (IDE) such as Eclipse.

Waterfall methodology

The requirements analysis stage consists of gathering the needs of the product/customer. The result of this stage is usually a text document written by the development team (headed by the analyst) that describes the needs that the team has understood the customer needs. It is not always easy to understand what the customer wants. This document is usually signed by the customer and is "contractual".

The design stage describes the internal structure of the product (e.g. which classes to use, how they are related, etc.), patterns to be used, the technology to be used, etc. The result of this stage is usually a set of diagrams (e.g. UML class diagrams, use cases, sequence diagrams, etc.) accompanied by textual information. If we decide at this stage to make a program based on object-oriented programming, it will also be at this stage when we use the bottom-up paradigm for the identification of objects, classes and the relationship between them.

The implementation stage means programming. The result of this phase is the integration of all the code generated by the programmers together with the associated documentation.

Once the product is finished, it goes to the testing stage. In this stage, different types of tests are generated to ensure that the final product does what it is expected to do. Obviously, during the implementation stage, tests are also performed at the local level - unit tests (e.g. at the level of a method, a class, etc.) - to see that this part, independently, works correctly.

The last stage, maintenance, starts when the product is finished. Although a product is finished, and no matter how many tests have been done, there are always errors (bugs) that must be fixed a posteriori.

MVC (Model- View-Controller)
The MVC standard is widely used today, especially in the web world. MVC attempts to separate three key elements of a program:

Model: represents the program's information. In many programs this part falls on a database and the classes that access it. The model is responsible for inserting, updating, deleting and querying program information, as well as controlling access privileges to that data. An alternative to the database is the use of text and/or binary files.

View: is the set of "screens" that configure the interface with which the user interacts. Each "screen" or view can be from a command line interface to a graphic interface, differentiating between mobile, tablet, computer, etc. Each view usually has a visual and an interactive part. The latter is responsible for receiving inputs/events from the user (e.g. click on a button) and communicating with the program controller(s) to request information or to report any changes made by the user. In addition, depending on the information received by the controller(s), it modifies the visual part accordingly.

Controller: is the part that controls the business logic. It acts as an intermediary between the view and the model. For example, by means of a user request (e.g. clicking a button), the view -through its interactive part- asks the controller to give it the list of items that the software has; the controller requests this information to the model, which provides it; the controller sends the information to the view, which is in charge of processing (i.e. interactive part) and displaying (i.e. visual part) the information received by the controller.

Thanks to the MVC pattern, the three parts are decoupled. This allows that having the same model and the same controller, the view can be modified without altering the other two parts. Likewise, if we change the model (e.g. change the database manager from MySQL to Oracle), the controller and the views should not be affected. The same if we change the controller. Thus, using the MVC pattern minimizes the impact of future changes and improves program maintenance. 

More information in the Wikipedia article: https://es.wikipedia.org/wiki/Modelo%E2%80%93vista%E2%80%93controlador.

To define the name of the packages, we have used the convention recommended by Oracle in the Java tutorials web: https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html. 

Environment:
The following environment is used:
- JDK >= 13
- Eclipse >= 2019-12 (4.14.0) 

Dependencies:
The following libraries are used:
- JUnit 5
- JavaFX 11 (no need to have it configured in the project from the beginning) 

Project structure:
If you open with Eclipse the project provided with this statement, you will see that, in the Package Explorer window, several directories appear:

- doc: contains the Javadoc documentation of the finished project. Open the index.html file in a web browser to see the program documentation.

- src: has three packages. Concretely we will have three packages called model, view (divided in cmd and gui) and controller. We have organized it this way because, as we have commented previously, in this practice we will use the MVC pattern.

- images: contains the images that will be used in the graphical view (view.gui).

- levels: contains the configuration files for each of the levels/rooms of the program.
levels/rooms of the program.

Thanks to the UOC (Open University of Catalonia).